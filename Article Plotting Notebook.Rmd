---
title: "Article Plotting Notebook"
output:
  pdf_document: default
  html_notebook: default
---
## Introduction

This Notebook outlines the code required to create the plot of different samples
of nutrients tested in water around the world. This plot will be used in an article
that will hopefully be published in the Canadian Journal of Chemical Engineering. 

The following code is used to install the required libraries. 
```{r, Initial}
library(tidyverse)
library(dataRetrieval)
library(ggmap)
library(maps)
library(mapdata)
library(RColorBrewer)
library(lubridate)
```

## USA dataset

This next chunk of code is uses the readWQPdata function from the dataRetriveal package
to download data from the Water Quality Portal. The Water Quality Portal is a collection
of three datasets of water quality sampling across the globe. 

The parameters are passed to the function to define the scope for the data to collection,
for this instance it limits the window for when the sample was first collected and
limits the database to solely the concentration of total Phosphorus.

```{r, dataget}
wqp.data <- readWQPdata('startDateLo' = "2017-01-01", 
                        'startDateHi' = "2018-12-31", 
                        characteristicName=c("Phosphorus")) %>%
        filter(ResultSampleFractionText=="Total") %>%
        mutate(Result = as.numeric(ResultMeasureValue)) %>%
        filter(!is.na(Result),
               ActivityMediaName=="Water")
```

The USA dataset come from a wide arrange of sampling stations, `r length(unique(wqp.data$MonitoringLocationIdentifier))` stations in total. 
These different stations measure different units on concentration so the data needs
to be cleaned and the units converted to mg/L. 
```{r, USA_units}
Case1 <- wqp.data$ResultMeasure.MeasureUnitCode=="ug/l"| wqp.data$ResultMeasure.MeasureUnitCode=="ug"
Case2 <- wqp.data$ResultMeasure.MeasureUnitCode=="ppm"| wqp.data$ResultMeasure.MeasureUnitCode=="mg/l as P"
Case3 <- wqp.data$ResultMeasure.MeasureUnitCode=="ppb"
Case4 <- wqp.data$ResultMeasure.MeasureUnitCode=="mg/kg"
Case5 <- wqp.data$ResultMeasure.MeasureUnitCode=="%"

wqp.data$Result[Case1|Case3] <- wqp.data$Result[Case1|Case3]/1000
wqp.data$Result[Case5] <- wqp.data$Result[Case5]*10

wqp.data$ResultMeasure.MeasureUnitCode[Case1|Case2|Case3|Case4|Case5] <- "mg/l"
wqp.data <- wqp.data %>% 
        filter(ResultMeasure.MeasureUnitCode=="mg/l") %>%
        filter(Result > 0)
```

The data comes from the years 2017-2018 so there are multiple measurements from the 
same stations. The average value is obtained and all extra unnecessary attributes 
are dropped. 

```{r USA_Drop}
wqp.data <- wqp.data %>%
        select(MonitoringLocationIdentifier, CharacteristicName, Result) %>%
        group_by(MonitoringLocationIdentifier, CharacteristicName) %>%
        summarise(Result = mean(Result), .groups = "keep")
```

All of the geo-spacial data for the USA testing location are kept in a separate 
database so the left merge is used to add longitude and latitude data. 
```{r USA_geo}
wqp.site <- whatWQPsites(siteid=wqp.data$MonitoringLocationIdentifier) %>%
        select(MonitoringLocationIdentifier, lng = LongitudeMeasure,
               lat = LatitudeMeasure)
USA <- wqp.data %>% 
        left_join(wqp.site, by = "MonitoringLocationIdentifier") %>%
        arrange(Result)
```

## Canada dataset

The Canadian dataset is much easier to handle and can be simply downloaded from the
canadian open data website. There is a limitation to the data in that the last updated 
data is from 2018. This will be the limitation for all the data as all other datasets 
are more recent. 

```{r Can}
canurl <- "https://www.canada.ca/content/dam/eccc/documents/csv/cesindicators/water-quality-canadian-rivers/2020/wqi-federal-raw-data-2020-iqe-donnees-brutes-fed.csv"
download.file(url = canurl, "Candata.csv")
Can.Data <- read_csv("Cansite.csv", col_types = cols(GUIDELINE_REFERENCE_RECOMMANDATION = col_character())) %>%
        filter(VARIABLE_NAME=="PHOSPHORUS") %>%
        mutate(DATE=dmy(DATE)) %>%
        select(DATE, VALUE_VALEUR, lat = LATITUDE, lng = LONGITUDE) %>%
        filter(DATE > dmy(01012017)) %>%
        group_by(lat, lng) %>%
        summarise(Avg_Con = mean(VALUE_VALEUR)) %>%
        arrange(Avg_Con)
```

## European datset

The european dataset comes from Waterbase. This data is open and easy to download
from their website but is very large, so be careful with your available disk space. 

```{r, euro}
eurourl <- "https://cmshare.eea.europa.eu/s/XdNc9oFeXyEJknN/download"
download.file(url = eurourl, "eurodata.zip", mode="wb")
unzip("eurodata.zip", exdir = ".")

eurosite <- read_csv("Waterbase_v2020_1_S_WISE6_SpatialObject_DerivedData.csv") %>%
        select(monitoringSiteIdentifier, lat, lon)
eurodata <- read_csv("Waterbase_v2020_1_T_WISE6_AggregatedData.csv") %>%
        select(monitoringSiteIdentifier, param = observedPropertyDeterminandLabel, year = phenomenonTimeReferenceYear,Result = resultMeanValue ) %>%
        filter(param == "Total phosphorus") %>%
        filter(year == "2017"| year == "2018" ) %>%
        left_join(eurosite) %>%
        arrange(Result)
```

## Map information

There are two maps used, a watercolour map from google and a map the world as an 
outline with the "worldHires" map. The google map does require the use of the google
maps api which will require an acount an the use of the "register_google" function. 
```{r maps}
gworld <- get_map(location = c(lon = -42, lat  = 54),
                  maptype = "watercolor",
                  zoom = 2,
                  source = "stamen")
world <- map_data("worldHires")
```

## Plotting

The color ramp palette function is used to create a custom gradient in the plotted
concentration colours. With that, all the data can be plotted on the maps.

```{r plot}
colfunc<-colorRampPalette(c("yellow","red","springgreen","royalblue"))
gplot <- ggmap(gworld, extent = "device", padding = 1) + 
        geom_polygon(data = world, aes(x=long, y = lat, group = group),fill = NA, color="black") + 
        geom_point(data = USA, aes(x =lng, y = lat, color = Result), size = 2, alpha = 0.5) +
        geom_point(data = Can.Data, aes(x =lng, y = lat, color = Avg_Con), size = 2, alpha = 0.5) +
        geom_point(data = eurodata, aes(x =lon, y = lat, color = Result), size = 2, alpha = 0.5) + 
        scale_color_gradientn(colours = colfunc(4)) 
gplot
```
